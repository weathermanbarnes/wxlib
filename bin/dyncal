#!/usr/bin/env python
# -*- encoding: utf8

import argparse

import dynlib


ap = argparse.ArgumentParser(
	usage='%(prog)s cmd [subcmd [...]] [options]',
	description='Command line interface to some pertinent dynlib functions.',
	epilog='Functions are based on dynlib version %s.' % getattr(dynlib, 'version', '[unknown]'),
)
ap.add_argument('cmds', metavar='cmd', type=str, nargs='+', help='Commands/subcommand to execute.')

# Configure output
ap.add_argument('-s', '--savepath', metavar='path', type=str, nargs='?', help='Save path the result files.')
ap.add_argument('-p', '--plotpath', metavar='path', type=str, nargs='?', help='Save path the resulting plots.')
ap.add_argument('-f', '--format', metavar='fmt', type=str, nargs='?', help='Save path the resulting plots.')

# Configure context
ap.add_argument('-c', '--context', type=str, metavar='context', nargs='?', help='Context for the calculations.')
ap.add_argument('-q', '--variable(s)', metavar='var', type=str, nargs='*', help='Which variables to use (if not predefined by the function itself).')
ap.add_argument('-l', '--level(s)', metavar='lev', type=str, nargs='*', help='Which vertical levels to use (if not predefined by the function itself).')
ap.add_argument('-t', '--time', type=str, metavar='time', nargs='*', help='Which time period to use.')


ap.parse_args()


__metafun__ = {}

class dynfun(object):
	def __init__(self, dependency_tables, provides_tables):
		self.deps = dependency_tables
		self.provides = provides_tables
		
		# Register what this function can do, to be able to recursively resolve dependencies
		for table in provides_tables:
			for plev in table[0]:
				for q in table[1]: 
					if (plev, q) in __metafun__:
						__metafun__[plev,q].append(self)
					else:
						__metafun__[plev,q] = [self, ]
		
		return

# TODO: Status quo: 
#
# Needs to build a database of what each function uses and provides, in order to
# (a) define what commands exist using dyncal
# (b) Know which dynlib function to call which what arguments,
# (c) potentially build dependency trees for chains of functions to call for a specific task
#
# Furthermore, a few additional commands must be available: e.g. "plot". These additional commands
# cannot be directly mapped to a dynlib function (or maybe the should be?), but to supplementary scripts
# like dyncal_plot.py


# the end
