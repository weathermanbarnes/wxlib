#!/usr/bin/env python

from __future__ import print_function, unicode_literals

import os
import sys
import re
import pickle

import numpy as np


''' Utilities for auto-creating documentation for dynlib

There is no pre-defined concept for integrating documentation of f2py modules 
within sphinx. Especially there is no pre-defined way to extract something 
equivalent to python docstrings from Fortran code and having them available in 
f2py modules. 

This module contains a set of utilities that 

#. parse the Fortran code for documentation strings and 
#. inject these strings into the f2py/python modules on import.

Lines starting with ``<whitespace>!@`` in Fortran will be interpreted as 
documentation and extracted. They must be directly followed by a definition of 
either a module or subroutine/function, otherwise a Warning is issued and the
documentation string is discarded.

The parsed documentation is stored in a python pickle object.
'''


PICKLE_FILENAME = '.dynfor_doc.pickle'



def _extract_name(linefrag):
	''' Extract the name of the subroutine/function/module from the remainder of the line '''

	m = re.findall('[A-Za-z0-9_]+', linefrag)

	return m[0]


def _insert_doc(module, func, fortran_doc, docstr):
	''' Do some plausability checks and then safe the docstring into the fortran_doc dictionary '''

	if not module and not func:
		raise RuntimeError('Got neither a module nor a function name for the docstring:\n\n%s' % docstr)
	if not module:
		raise RuntimeError('Found a function `%s` without module' % func)
	if not func:
		fortran_doc[module] = docstr
	else:
		fortran_doc['%s.%s' % (module, func)] = docstr


def parse_fortran_file(fname, fortran_doc):
	'''Parse a fortran source file to extract documentation strings
	
	Parameters
	----------
	fname : str
	    Filename of the Fortran source
	fortran_doc : dict
	    Dictionary containing the extracted documentation strings, 
	    indexed by strings like 'module' or 'module.func'. The parameter
	    is changed in-place.
	
	Returns
	-------
	None
	'''

	if not os.path.isfile(fname):
		raise ValueError('File not found: `%s`' % fname)

	f = open(fname)
	srclines = f.readlines()
	f.close()
	
	indoc = False
	inmodule = None
	for lnr, line in zip(range(1,len(srclines)+1), srclines):
		# Remove indent
		line = line.lstrip()

		# If line is part of a comment that is marked as part of the documentation
		if line[:2] == '!@':
			if len(line) == 2:
				_srcdoc = ''
			else:
				# Allow a little flexibility in the formatting 
				# by allowing an option whitespace character after the !@
				if line[2] in [' ', '\t']:
					_srcdoc = line[3:]
				else:
					_srcdoc = line[2:]

			if not indoc:
				indoc = True
				srcdoc = _srcdoc
			else:
				srcdoc += _srcdoc

		# If first line after a documentation comment
		elif indoc:
			known_entities = [
				'subroutine', 
				'recursive subroutine',
				'function',
				'recursive function',
			]
			documented = False
			for entity in known_entities:
				if line[:len(entity)] == entity:
					name = _extract_name(line[len(entity):])
					_insert_doc(inmodule, name, fortran_doc, srcdoc)
					documented = True
			if not documented and line[:6] == 'module':
				name = _extract_name(line[6:])
				_insert_doc(name, None, fortran_doc, srcdoc)
				documented = True
				inmodule = name
			if not documented:
				raise Warning('Found a documentation comment without associated module/function '
						'at line %d of file `%s`, and hence will be discarded. '
						'The docstring reads:\n\n%s' % (lnr, fname, srcdoc) )
			indoc = False
			srcdoc = ''

		# Entering undocumented module 
		elif line[:6] == 'module':
			inmodule = _extract_name(line[6:])


def save_fortran_doc(fortran_doc):
	''' Save the fortran documentation dictionary in a pickled file 

	The file name is pre-defined in ``docutils.PICKLE_FILENAME``.
	
	Parameters
	----------
	fortran_doc : dict
	    Fortran documentation to be saved
	
	Returns
	-------
	None
	'''

	f = open('../%s' % PICKLE_FILENAME , 'wb')
	pickle.dump(fortran_doc, f, protocol=2, fix_imports=True)
	f.close()


def takeover(f2pymodule, name, module):
	''' Take over the contents of a fortran module

	Makes all functions available in a Fortran module available in the given python module. 
	The function also injects docstrings that were compiled from magic comments within the
	Fortran source code. The original docstrings generated by f2py from the routine 
	signature are backed up to the attributes ``__f2pydoc__``.

	Parameters
	----------
	f2pymodule : Fortran module
	    Fortran module containing the routines to take over
	name : str
	    Name of the Fortran module
	module : python module
	    Python module recieving the Fortran routines
	
	Returns
	-------
	None
	'''

	pth = os.path.abspath(os.path.join(os.path.dirname(__file__), PICKLE_FILENAME))
	if os.path.isfile(pth):
		f = open(pth, 'rb')
		fortran_doc = pickle.load(f)
		f.close()
	else:
		print('Warning: Fortran documentation not found. Make sure you have compiled dynlib.')
		fortran_doc = {}

	# Setting documentation for the functions within the module
	for funcname, value in f2pymodule.__dict__.items():
		if type(value) == np.ndarray:
			continue
		# Backup the f2py generated docstring
		value.__f2pydoc__ = value.__doc__
		# Set the doctring from the fortran_doc extracted documentation
		value.__doc__ = fortran_doc.get('%s.%s' % (name, funcname), None)
		# Make available as a member of this python module
		setattr(module, funcname, value)

	# Setting documentation for the module itself
	module.__f2pydoc__ = f2pymodule.__doc__
	module.__doc__ = fortran_doc.get(name, None)
	f2pymodule.__f2pydoc__ = f2pymodule.__doc__
	f2pymodule.__doc__ = fortran_doc.get(name, None)


#
